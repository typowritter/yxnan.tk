<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>自动化传图</title>
  <meta name="description" content="Texts about blog links and games.">
  <style>
    div.body {
        margin-top: 0%;
        margin-bottom: 5%;
        margin-right: 5%;
        margin-left: 5%;
    }
  </style>
</head>
<body>
  <!--<BODY TEXT=#000000 BGCOLOR=#FFFFFF link=#000000 vlink=#888888>-->
  <div align="right">
    <font face="sans"></font>
    <table border="0" width="100%">
      <tr>
        <td width="100%" valign="middle"><b>yxnan</b></td>
        <td nowrap="nowrap" valign="middle">
          <a href="/">主页</a>
        </td>
        <td valign="middle">&nbsp;&nbsp;&nbsp;<font size="+1">|</font>&nbsp;&nbsp;&nbsp;</td>
        <td nowrap valign="middle">English (unavailable)
          <!-- <a href="/en/auto-install">English</a> -->
        </td>
        <td valign="middle">&nbsp;&nbsp;&nbsp;<font size="+1">|</font>&nbsp;&nbsp;&nbsp;</td>
        <td nowrap="nowrap" valign="middle">
          <a href="/blog/about">链接</a>
        </td>
        <td valign="middle">&nbsp;&nbsp;&nbsp;<font size="+1">|</font>&nbsp;&nbsp;&nbsp;</td>
        <td nowrap="nowrap" valign="middle">
          <a href="mailto:yxnan@pm.me">联系</a>
        </td>
        <td valign="middle">&nbsp;&nbsp;&nbsp;</td>
      </tr>
    </table>
  </div>
  <hr size="3" color="black">
  <br>
  <br>
  <div class="body">
    <!--============================================================-->
    <font size="+4">自动化传图</font><br>
    <br>
    <b>复杂性不能消除，只可能隐藏</b><br>


    <br><br><br>
    <font size=+2>
    目标
    <br><br>
    </font>

    我想让其他好友在无需登录服务器的情况下，也能够安装地图。<br>
    也即，在不知道服务器账号密码（甚至不知道 SSH，不知道 Linux）的情况下，将一个 VPK 文件放置到某个目录中，然后发送 SIGTERM 给游戏进程，使它重启。<br>
    这是可能做到的吗？<br>
    <br>
    当然，不然也不会有这篇文章了。
    <br><br>

    <br><br><br>
    <font size=+2>
    实现思路
    <br><br>
    </font>

    首先，说到文件传输协议，最简单的就是 FTP 了，所以我们可以建立一个 FTP 目录用来放置上传文件。<br>
    那么如何自动安装呢？简单搜索，我找到了一个工具：iwatch.<br>
    查看手册可知，它可以监视一个目录下的所有文件操作，并触发相应命令，听起来正是我们需要的。<br>
    只需要在发现新文件时，将其解压到指定目录就可以了。<br>
    <br>
    Ok，我们逐一考察各部分工作：
    <br><br>

    <br><br><br>
    <font size=+2>
    FTP
    <br><br>
    </font>

    之前已经配置好了一个公共匿名 FTP，但直接用它上传显然是不安全的，因此我们建立一个用户，并且只有它能上传 FTP（仅显示部分配置）：<br>
    <br>
    <pre>
    <b>/etc/vsftpd.conf</b><br>
        write_enable=YES            # 启用文件写入
        local_enable=YES            # 允许本地用户登录
        user_sub_token=$USER
        local_root=/var/ftp/$USER   <b># 我已经将用户家目录设置到了这里</b>
        chroot_local_user=YES       # 限制本地用户到家目录

        userlist_enable=YES
        userlist_file=/etc/vsftpd.allow

        <span style="color: rgb(255, 0, 0);">chown_uploads=YES</span>
        chown_username=yxnan        # 上传后将文件所有者改成我们自己
        local_umask=000             # 方便我们作为 Others 进行操作

        ssl_enable=YES
        allow_anon_ssl=NO
        force_local_logins_ssl=YES  # 强制启用安全连接（需要自行配置证书）
        force_local_data_ssl=YES
    </pre>
    <br>

    除此之外，我们还需要正确设置目录权限，使得 FTP 用户可以上传文件，但无法删除上传目录本身。
    <br><br>

    <br><br><br>
    <font size=+2>
    目录监视
    <br><br>
    </font>

    我们需要在上传完成时取得目标文件，因此应该监视文件关闭动作，如下：<br>
    <br>
    <pre>
    <b>~/watch-ftp</b><br>
        #!/bin/bash
        screen -dm -S watch iwatch -e <span style="color: rgb(255, 0, 0);">close_write</span> -c "~/process-file" /var/ftp/[USER]/upload
    </pre>

    其中，<code>~/process-file</code> 是我们将要编写的处理脚本。<br>
    实际上，<code>iwatch</code> 可以用 <code>%f</code> 代表触发动作的文件，但我在测试中发现，它不支持中文，因此只好在处理脚本里手动读取。<br>
    （等有时间了翻翻它的源码，加上中文支持）
    <br><br>

    <br><br><br>
    <font size=+2>
    处理脚本
    <br><br>
    </font>

    这里是重中之重，我将实现 VPK 及常见压缩包的自动安装，以及接受重启命令：<br>
    <br>
    <pre>
    <b>~/process-file</b><br>
        #!/bin/bash

        upload_dir=/var/ftp/[USER]/upload
        log_file=~/watch_log.txt
        log_file_pub=~/site/misc/watch_log.txt

        logwrite() {
            echo "[`date +%m/%d/%y-%H:%M:%S`] $1" >> $log_file
        }

        log_final() {
            echo >> $log_file
            iconv -f utf8 -t gbk $log_file > $log_file_pub
        }

        <b># 检查不合法上传</b>
        if ! [[ $(ls -1 $upload_dir | head -1) =~ <b>vpk|zip|rar|7z|restart</b> ]]; then
            rm -rf $upload_dir/*
            exit
        fi

        <b># 处理重启服务器指令</b>
        reset_cmd="$upload_dir/restart"
        if [ <span style="color: rgb(255, 0, 0);">-e $reset_cmd</span> ]; then
            screen -S l4d2 -X stuff "quit^M"  # 重启服务器
            logwrite "服务器重启"
            rm -rf $reset_cmd
            log_final && exit
        fi


        <b># 处理地图上传</b>
        fullpath=$(<span style="color: rgb(255, 0, 0);">ls -1 $upload_dir/*.{vpk,zip,rar,7z} | head -1</span>) # 取得上传的文件
        filename=$(basename "$fullpath")
        <b>VPK=~/.local/bin/vpk
        UNVPK=~/.local/bin/unvpk</b>
        GETMAPCMD=~/getmapcmd

        <b># 精简vpk文件，取得建图代码，并安装</b>
        process_vpk () {
            vpk_tmp=$(mktemp -d -t vpk-XXXX)
            vpk_name="$(basename "$1")"
            vpk_dist="$ADDONS/$vpk_name"

            # vpk 解包有很小几率编码错误，使用 unvpk
            unvpk_result=$(<b>$UNVPK -C $vpk_tmp "$1"</b> | tail -1)
            logwrite "unvpk: $unvpk_result"

            cd $vpk_tmp && mv ' '/* .
            shopt -s extglob
            eval 'rm -rf !(maps|missions|models|scripts|addoninfo.txt)'

            if [ <span style="color: rgb(255, 0, 0);">-e missions</span> ]; then
                mapcmd="，建图代码：$(ls missions/* | $GETMAPCMD)"
            fi

            <b>$VPK -c $vpk_tmp "$vpk_dist"</b> && cd -

            if [ <span style="color: rgb(255, 0, 0);">-e "$vpk_dist"</span> ]; then
                logwrite "地图已安装$mapcmd"
            else
                logwrite "地图安装失败，请联系管理员解决"
            fi

            rm -rf $vpk_tmp
        }

        unar_tmp=$(mktemp -d -t unar-XXXX)
        logwrite "收到文件：$filename"

        if [ <b>${filename: -4} == ".vpk"</b> ]; then
            process_vpk "$fullpath"
        elif <span style="color: rgb(255, 0, 0);">unar -o $unar_tmp "$fullpath"</span>; then
            rm -rf "$fullpath"

            <b>find $unar_tmp -name '*.vpk' | while read vpk_file</b>
            do
                logwrite "成功解压：$(basename "$vpk_file")"
                process_vpk "$vpk_file"
            done
        else
            logwrite "试图解压失败，放弃文件"
        fi

        rm -rf $unar_tmp "$fullpath"
        log_final

    </pre>
    <br>

    你看到了我是怎样实现重启的吗？<br>
    <br>
    注意，我这里假设了同一时间只会有一个文件传输完成（上面对 <code>ls</code> 输出取了 <code><b>head -1</b></code>）<br>
    这是一个暂时的权宜之计，等到 <code>iwatch</code> 支持中文后，就可以直接传入文件名，不需要自己读了。<br>
    <br>
    为方便起见，这里已经把 log 放置到了 https 服务器上，直接在网页里就能查看：<a href="https://yxnan.cn/misc/watch_log.txt">watch_log.txt</a>
    <br><br>

    <br><br><br>
    <font size=+2>
    一键上传
    <br><br>
    </font>

    实际上，整套流程已经可以正常工作了，只需要把 FTP 账号密码告诉小伙伴就可使用。<br>
    <br>
    “但是，FTP 我也弄不明白，该怎么办呢？”<del>（没救了，等死吧.jpg）</del><br>
    <br>
    这里就需要终极保姆服务了：<br>
    <br>

    <img src="serverctl.png" style="vertical-align:middle;margin:0px 50px">
    <br><br><br>

    怎么样，现在还有人说不会？罚你去把 hehe 全系列单通一遍 :-)
    <br><br>

    <br><br><br>
    <font size=+2>
    PS
    <br><br>
    </font>

    上面用到的部分工具：<a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2181019651">Linux Dev Toolchain Collection</a><br>
    （我自己的 Steam 指南，引 流 之 主）
  </div>
</body>
</html>
